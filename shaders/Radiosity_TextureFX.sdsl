[TextureSource]


shader Radiosity_TextureFX : TextureFX
{

float2 R = ViewSize;
float aspectX = 1.0;
float time = 0.0;
#define SAMPLES 128
#define SAMPLES2 32

float maxDist = 0.15;
// float distFieldScale = 0.1;

// float4 color = .1;





float sphereSDF(float2 p, float size) {
    return length(p) - size;
}

float boxSDF(float2 p, float2 size) {
    float2 r = abs(p) - size;
    return min(max(r.x, r.y),0.) + length(max(r,float2(0,0)));
}

void addObj(inout float dist, inout float3 color, float d, float3 c) {
    if (dist >= d) {
        dist = d;
        color = c;
    }
}

float3 calcNormal( float2 p ) // for function f(p)
{
    float h = 0.09961; // replace by an appropriate value
    float2 k = float2(1,-1);
    return normalize( k.xyy*texDist( p + k.xyy*h) + 
                      k.yyx*texDist( p + k.yyx*h) + 
                      k.yxy*texDist( p + k.yxy*h) + 
                      k.xxx*texDist( p + k.xxx*h));
}

float texDist(float2 p){
    float samp = Texture0.SampleLevel(Sampler0, (p + .5), 0).r;
    // float samp = Texture0.Load(int3( (p + .5) / 1 * R, 0)).r;
    return samp;
}



void addObjTex(inout float dist, inout float3 color, float d, float2 p) {
    if (dist > d) {
        dist = d;
        color = Texture1.SampleLevel(Sampler0, (p + .5), 0).rgb* 1;

        // color =  Texture1.Load(int3( (p + .5) / 1 * R, 0)).r;
    }
}


void scene(in float2 pos, out float3 color, out float dist) {
    dist = 1e9;
    // color = float3(0,0,0);
    // addObj(dist, color, sphereSDF(pos - float2(0,-2), 0.5),  float3(1, 1, 1)*2);
    // addObj(dist, color, boxSDF(pos - float2(.75,0), float2(.01, 0.5)), float3(1.0,.5,.5));
    // addObj(dist, color, boxSDF(pos - float2(-.75,0), float2(.01, 0.5)), float3(.5,.5,1.0));
   
    addObjTex(dist, color, texDist(pos), pos);
    // addObj(dist, color, boxSDF(pos - float2(mouse), float2(0.01, 0.1)), float3(.0,.0,.0));

}

float3 scene2(in float2 pos) {
    float dist = 1e9;
    // color = float3(0,0,0);
    // addObj(dist, color, sphereSDF(pos - float2(0,-2), 0.5),  float3(1, 1, 1)*2);
    // addObj(dist, color, boxSDF(pos - float2(.75,0), float2(.01, 0.5)), float3(1.0,.5,.5));
    // addObj(dist, color, boxSDF(pos - float2(-.75,0), float2(.01, 0.5)), float3(.5,.5,1.0));
    float3 color;
    addObjTex(dist, color, texDist(pos), pos);
    return color;
    // addObj(dist, color, boxSDF(pos - float2(mouse), float2(0.01, 0.1)), float3(.0,.0,.0));

}


void trace(float2 p, float2 dir, out float3 c, out float marchedDist) {
    float marched = 0;
    float d;
    int bounces = 0;
    float2 start = p;
    float localMax = maxDist;
    for (int j = 0; j < SAMPLES2; j++) {
        scene(p, c, d);
        
        marched += d;

        if(marched > localMax) break;
        if (d <= .001 ) {  
            
            // Stupid Refleciton
            if (c.r < .1) {
                bounces++;

                // dir = reflect(dir, normalize(Texture2.SampleLevel(Sampler0, (p + .5), 0).rg -.5));
                dir = refract(dir, normalize(Texture2.SampleLevel(Sampler0, (p + .5), 0).rg -.5),1.52);

                p -= dir * .01;


                // float3 normal = calcNormal(p);
                // localMax = .2;
                // d = .001;
                // marched += .5;
                // marchedDist = marched;
                // return;
            }
            else{
                marchedDist = marched;
                return;
            } 

            // marchedDist = marched;
            // return;
            // if(bounces > 2)  return;
        }

        p -= dir * float2(1,aspectX) * d;
    }


    c = float3(0,0,0);
}

// Use golden noise instead! https://www.shadertoy.com/view/ltB3zD

float random (in float2 _st) {
    
    return frac(sin(dot(_st.xy,
        float2(12.9898,78.233)))*
        43758.5453123 );
}


stage override float4 Shading()
{
// Normalized pixel coordinates (from 0 to 1) ( maybe )
float2 uv = (streams.TexCoord.xy -.5); //* R/R.x
float3 c;
float3 col = float3(0,0,0);
for (int i = 0; i < SAMPLES; i++) {
    float t = (float(i) + random(uv+float(i)))/ float(SAMPLES) * 2. * 3.14159265359;        
    float marchedDist;
    trace(uv, float2(cos(t+time), sin(t+time)), c, marchedDist);
      c = lerp(c,0,pow(abs(marchedDist/maxDist), maxDist));
    col += c;

}
col /= float(SAMPLES);

// Output to screen
    // return saturate(float4(col + Texture2.SampleLevel(Sampler0, streams.TexCoord.xy, 0).rgb * col ,1.0)  + color);
    return saturate(float4(col, 1.0));
}


};